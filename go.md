## 1. 并发与并行
并发是一段时间内两个或两个以上的任务被执行，并行是同一时刻执行多个任务。
并发是逻辑上的概念，并行是物理上的运行状态。

## 2. gorutine 并发原理
MGP
一个M关联一个内核线程
一个P对应一个处理器，也是M所需的上下文环境，P的数量可通过GOMAXPROCS()设置，即有多少个goruntine可以同时执行。
P维护一个gorutine队列，用于gorutine的调度。
一个G代表gorutine，一个P会链接一个或多个G，也就是一个或多个gorutine
因此goruntine是基于线程的更轻量级的实现

## 3. 分布式生成uuid算法
（1）数据库自增id
（2）Redis 单线程可使用incr／incrby命令，集群可通过设置步长来保证唯一
（3）纳秒+业务属性+机器属性+用户属性+随机值
（4）第三方开源中间件如zookeeper

## 4. epoll／poll／select 区别
select 最大连接数受进程可打开的文件描述符数量限制，并且每次轮询去查找已就绪的IO事件消耗CPU时间
poll 没有最大连接数限制，因为其底层实现是链表，其也需要轮询去查找已就绪的IO事件
epoll 没有最大连接数限制，并且不需要轮询去查找已就绪的IO事件，其用epoll_ctl注册IO事件，当有已就绪的IO事件时，会像回调函数一样，通知监听方。

连接数较少并且都十分活跃时使用select和poll性能会更高，否则连接数较多或不是很活跃时使用epoll性能更高。

## 5. 多进程模型和多线程模型
多进程：更高的容错性、隔离性、
多线程：更方便数据共享，频繁的创建和销毁使用多线程模型性能更好。

## 6. 数据库ACID特性
（1）原子性：要么全执行，要么全不执行
（2）持久性：持久化存储
（3）隔离型：事务执行相互独立
（4）一致性：数据完整性

## 7. 数据库事务隔离级别及应用场景
（1）读未提交：默认的隔离级别，一个事务未提交，数据可被其他事务读取，前者事务回滚容易导致脏读。
（2）读已提交：一个事务提交后，其变更才会被其他事务读取到。可避免脏读，可能造成不可重复读的问题。
（3）可重复读：在一个事务中看到的数据始终是一致的。可避免脏读和不可重复读，但可能导致幻读的现象。
（4）串行：最高隔离级别，所有事务按顺序执行，性能低。可避免脏读、不可重复读、幻读。
常用的是读已提交和可重复读
共享锁（读锁），排他锁（写锁）

## 8. 分布式事务解决方案
（1）多个事务参与者选定一个协调者，协调者负责协调是全部回滚还是全部提交。可引入超时机制增强容错性
（2）将本地操作和发送消息到消息队列放到同一个事务中，下游通过重试机制保证最终一致性。本质是通过消息队列将分布式事务转化为两个本地事务。
（3）开源阿里GTS 

## 9. 缓存击穿、缓存穿透、缓存雪崩解决方案
缓存穿透：缓存零值或空值键
缓存雪崩：过期时间加随机值
缓存击穿：（1）读取键时查看键过期时间，如果即将过期，则更新键。（2）多级缓存（3）新开一个线程去更新热点数据 （4）当读取到一个键为空时，不马上去load db而是先利用setnx加一个锁，防止其他gorutine访问，然后load db，更新缓存之后，释放锁，让其他gorutine访问。

## 10. fork一个子进程
子进程继承父进程堆栈、环境变量、工作目录等
子进程独有PID、

## 11. Redis 分布式锁超时导致两个线程同时获得锁问题的解决方案
在一个gorutine拿到锁的同时，再去开一个gorutine，用于在锁即将过期时重新设置锁过期时间，当主gorutine执行结束后，释放锁，并且销毁辅助的gorutine。

## 12. 为什么mysql使用B+树2而不是B+树
B+树由于非叶子节点只用作索引不保存数据，非常适合磁盘读写场景，只需要把每个节点的大小设置成磁盘页的大小就行了。
而B树非叶子节点也保存数据，所以一个磁盘页存储的节点数量就会变少，所以使用B+树可减少IO读写次数

## 13. 普通索引和唯一索引
普通索引查询会有一个查询下一条数据的过程，唯一索引查找到数据直接返回，但是由于B+树非叶子节点按磁盘页存储，仅仅是多一次指针寻址，所以查询效率差异很小
由于唯一索引需要保证数据的唯一性，所以唯一索引更新代价更大。
普通索引只取前16个字节，而唯一索引会取全字节

## 14.神经射手服务器主要监控哪些指标
nginx 可用性、nginx 连接数
进程是否重启（服务可用性）、内存和cpu利用率、同时在线用户数
redis缓存命中率、redis可用性、redis qps、redis 慢查询
mysql缓存命中率、mysql可用性、mysql连接数、mysql qps、mysql 慢查询
接口可用性

## 15. Go有什么优势，为什么选Go
优势：
性能好，媲美c++和java，比python和php快
开发效率高
并发性好 gorutine channel
编译快
缺点：
生态不完善，和java比差的很远
依赖包管理不够完善，无法创建固定版本的依赖关系树

## 16. 遇到过什么难以解决的问题
（1）beego版本不对，导致服务不可用
（2）keys命令导致redis读写慢
（3）服务端主动发送天梯奖励时，如果当前用户在线，导致的用户数据不正确。通过延迟执行池解决
(4) battle泄漏，battle和client的比例不是1比2的关系，并且差很多。然后通过pprof去查看堆栈和gorutine发现确实有gorutine泄漏，并且很多gorutine运行了相当长的时间，因为一场战斗结算也就几分钟，后来分析应该是gorutine没有正常退出，然后去试玩游戏，发现结算非常慢，分析有可能是mysql慢查询，或者redis慢查询，最后定位问题有人用了keys命令，导致整个系统运行缓慢。

## 17. golang 内存泄漏解决方案
pprof

## 18. 为什么性别字段不适合建立索引
因为性别字段区分度很低，如果建立索引，会有额外的io消耗，因为在索引中拿到的是数据地址还要去磁盘读取数据。所以加上索引会比不加索引更慢。

## 19. 聚簇索引
一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

## 20. redis 删除一个巨大的set造成阻塞的解决方案
 使用scan命令，每次获取一定数量的数据，进行分批删除。

## 21. 生产环境中，redis应该被禁用的命令
keys，smembers