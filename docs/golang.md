### 1. 同一个struct的两个实例可否用==比较？不同struct的两个实例可否用==比较？struct类型可否作为map的key？

+ 同一struct类型的两个实例，当结构体中不包含不可比较的类型（切片、map）时，可以使用==比较，否则不能使用==比较
+ 不同struct类型的两个实例不能用==比较，因为编译报错
+ 如果struct类型中只包含可比较类型则可以用作map的key，否则不行

### 2. GC（垃圾回收）及运行原理

使用算法：三色标记+混合写屏障+辅助gc

触发时机：

* 定时触发（每2分钟内未执行过gc）
* 分配内存时触发（当前内存是上一次gc执行完内存的两倍）
* 手动触发（runtime.GC()）

执行流程：

* gc初始化：收集根节点（全局对象、G Stack），开启写屏障，开启辅助GC（需要stw，但1.9版本之后已优化，不需要stw）
* 标记：初始时节点都为白色，从根节点出发，标记为灰色，然后放入灰色集合，然后从灰色集合拿出来一个将其标记为黑色，并将其引用的对象标记为灰色，并放入灰色集合，然后重复以上操作，直到灰色集合为空，此时要么是黑节点要么是白节点，白节点即为要清理的对象。（此阶段与用户代码并行）
* 标记结束：关闭写屏障和辅助GC（需要stw）
* 清理：清理白色节点（此阶段与用户代码并行）

辅助GC：当用户程序分配内存的速度比回收速度快时，辅助gc会执行stw停掉用户程序，用更多的cpu来跑垃圾回收程序。如果不这样，那么gc会一直卡在标记阶段，无法正常执行。

写屏障: 由于标记阶段,与用户代码并行,所以可能出现被引用的对象被标记为白色的问题。例如以下场景：

A首先被标记为黑色，B引用C，用户代码将B标记为黑色之前将引用给了C，这时B被标记为黑色，但是由于A已经被扫描过，所以A引用C不会再此被扫描，所以C会被标记成白色，但是应为黑色。

写屏障就是在标记阶段，与用户代码并行时，监控对象的状态，并重新标记。

流程图如下：

![gc](../images/gc.png)

参考：

https://juejin.im/post/6844903793855987719

https://www.jianshu.com/p/e20aaa039229

http://yangxikun.github.io/golang/2019/12/22/golang-gc.html

### 3. Go调度器原理，用了什么系统调用



参考：

https://tonybai.com/2020/03/21/illustrated-tales-of-go-runtime-scheduler/

https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/

### 4. Slice与数组区别，Slice底层结构及实现原理



### 5. Map 实现原理



### 6. Sync.Map 实现原理



### 7. Chanel 底层原理



### 8. Defer 常见坑



### 9. select， *select是随机的还是顺序的？*



### 10. context



### 11. Map 如何顺序读取



### 12. Golang内存泄漏，线上如果出现如何排查解决



### 13. Slice常见坑，len，cap，扩容等



### 14. 反射



### 15. sync.Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？



### 16.  goroutine泄漏有没有处理



### 17. go使用踩过什么坑



### 18. go优缺点



### 19. go的值传递和引用



### 20. go的锁如何实现，用了什么cpu指令



### 21. go的runtime如何实现



### 22. go什么情况下会发生内存泄漏？



### 23. 怎么实现协程完美退出？



### 24. 用channel实现定时器？



### 25. 怎么理解go的interface



### 26. c++ 和 go对比



### 27. go的new和make区别



### 28. go怎么从源码编译到二进制文件



### 29. go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？



### 30. *Go语言局部变量分配在栈还是堆？*



### 31 init 函数执行顺序





















