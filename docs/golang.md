### 1. 同一个struct的两个实例可否用==比较？不同struct的两个实例可否用==比较？struct类型可否作为map的key？

+ 同一struct类型的两个实例，当结构体中不包含不可比较的类型（切片、map）时，可以使用==比较，否则不能使用==比较
+ 不同struct类型的两个实例不能用==比较，因为编译报错
+ 如果struct类型中只包含可比较类型则可以用作map的key，否则不行

### 2. GC（垃圾回收）及运行原理

使用算法：三色标记+混合写屏障+辅助gc

触发时机：

* 定时触发（每2分钟内未执行过gc）
* 分配内存时触发（当前内存是上一次gc执行完内存的两倍）
* 手动触发（runtime.GC()）

执行流程：

* gc初始化：收集根节点（全局对象、G Stack），开启写屏障，开启辅助GC（需要stw，但1.9版本之后已优化，不需要stw）
* 标记：初始时节点都为白色，从根节点出发，标记为灰色，然后放入灰色集合，然后从灰色集合拿出来一个将其标记为黑色，并将其引用的对象标记为灰色，并放入灰色集合，然后重复以上操作，直到灰色集合为空，此时要么是黑节点要么是白节点，白节点即为要清理的对象。（此阶段与用户代码并行）
* 标记结束：关闭写屏障和辅助GC（需要stw）
* 清理：清理白色节点（此阶段与用户代码并行）

辅助GC：当用户程序分配内存的速度比回收速度快时，辅助gc会执行stw停掉用户程序，用更多的cpu来跑垃圾回收程序。如果不这样，那么gc会一直卡在标记阶段，无法正常执行。

写屏障: 由于标记阶段,与用户代码并行,所以可能出现被引用的对象被标记为白色的问题。例如以下场景：

A首先被标记为黑色，B引用C，用户代码将B标记为黑色之前将引用给了C，这时B被标记为黑色，但是由于A已经被扫描过，所以A引用C不会再此被扫描，所以C会被标记成白色，但是应为黑色。

写屏障就是在标记阶段，与用户代码并行时，监控对象的状态，并重新标记。

流程图如下：

![gc](../images/gc.png)

参考：

https://juejin.im/post/6844903793855987719

https://www.jianshu.com/p/e20aaa039229

http://yangxikun.github.io/golang/2019/12/22/golang-gc.html

### 3. Go调度器原理

+ GPM模型  

  一个G对应一个goroutine

  一个P对应一个逻辑处理器，并维护一个G的本地运行队列，数量与GOMAXPROCS数量一致，指最大并行数

  一个M对应一个内核线程，数量不固定，由go运行时指定，默认设置为最大10000.

  gorutine 与 内核线程 N:M映射

+ 全局运行队列

  go运行时会维护一个G的全局运行队列，p会在一定条件下，来全局运行队列中拿G放到自己的本地运行队列中。全局运行队列会使用mutex来控制多个p的并发访问。

  全局运行对列使用mutex来实现多个p的并发访问，由于锁的竞争太严重，所以每个p中引入了本地运行队列，以减少锁的竞争。

+ 本地运行队列

  每一个p都会维护一个G的本地运行队列，p会不断的在本地运行队列中取出G挂载到内核线程上去运行。当通过 `go` 关键字创建一个新的 goroutine 的时候，它会优先被放入 P 的本地队列。

+ netpoll（网络轮询器）

  比如select/poll/epoll等IO多路复用，goroutine将被挂起，直到IO事件触发，这是将goroutine重新放回运行队列中。

+ 调度过程

  p首先检查**本地运行队列**，如果本地运行队列为空，首先会去检查**全局运行队列**（需要加锁），如果全局运行队列也为空，然后去检查**网络轮询器**(network poller)中是否有IO事件被触发，如果还没有，这时会进行”**窃取**“，即去其他p的本地运行队列中拿一部分G放到自己的本地运行队列中。

+ sysmon

  go程序在启动时，会启动一个sysmon（系统监视器）的m，这个m无须与p绑定即可运行，每20us~10ms启动一次,它完成的工作主要有：

  - 释放闲置超过5分钟的span物理内存；
  - 如果超过2分钟没有**垃圾回收**，强制执行；
  - 将长时间未处理的netpoll结果添加到任务队列；
  - 向长时间运行的G任务发出**抢占调度**；
  - 收回因syscall长时间阻塞的P；

+ 抢占式调度

  当某个goroutine执行超过10ms，sysmon会向其发起抢占调度请求，goroutine调度没有时间片的概念，通过设置标记来进行抢占式操作。

  基于协作的抢占式调度器 - 1.2 ~ 1.13

  基于信号的抢占式调度器 - 1.14 ~ 至今

+ channel

  试图写入或读取channel而被阻塞的gorutine会被阻塞到channel中的sendq或recvq（写/读队列中），不会放到全局运行队列，或者p的本地运行队列中

+ 总结

  goroutine的调度不需要让 CPU **在用户态和内核态之间切换**，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多

![](../images/goroutine.png)

参考：

https://tonybai.com/2020/03/21/illustrated-tales-of-go-runtime-scheduler/

https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/

https://wudaijun.com/2018/01/go-scheduler/

### 4. Slice与数组区别，Slice底层结构及实现原理



### 5. Map 实现原理



### 6. Sync.Map 实现原理



### 7. Chanel 底层原理



### 8. Defer 常见坑



### 9. select， *select是随机的还是顺序的？*



### 10. context



### 11. Map 如何顺序读取



### 12. Golang内存泄漏，线上如果出现如何排查解决



### 13. Slice常见坑，len，cap，扩容等



### 14. 反射



### 15. sync.Pool用过吗，为什么使用，对象池，避免频繁分配对象（GC有关），那里面的对象是固定的吗？



### 16.  goroutine泄漏有没有处理



### 17. go使用踩过什么坑



### 18. go优缺点



### 19. go的值传递和引用



### 20. go的锁如何实现，用了什么cpu指令



### 21. go的runtime如何实现



### 22. go什么情况下会发生内存泄漏？



### 23. 怎么实现协程完美退出？



### 24. 用channel实现定时器？



### 25. 怎么理解go的interface



### 26. c++ 和 go对比



### 27. go的new和make区别



### 28. go怎么从源码编译到二进制文件



### 29. go函数中，返回值未命名，发生了panic，但是在函数内recover了。函数返回什么值？



### 30. *Go语言局部变量分配在栈还是堆？*



### 31 init 函数执行顺序





















